"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[477],{10:n=>{n.exports=JSON.parse('{"blogPosts":[{"id":"struct-type-func-overload","metadata":{"permalink":"/blog/struct-type-func-overload","editUrl":"https://github.com/unional/unional.github.io/edit/main/blog/blog/2021-04-10-structural-type-and-function-overload.mdx","source":"@site/blog/2021-04-10-structural-type-and-function-overload.mdx","title":"Structural Type vs Function Overload","description":"Structural type is what I want.","date":"2021-04-10T00:00:00.000Z","formattedDate":"April 10, 2021","tags":[{"label":"type-system","permalink":"/blog/tags/type-system"},{"label":"structural-type","permalink":"/blog/tags/structural-type"},{"label":"function-overload","permalink":"/blog/tags/function-overload"}],"readingTime":1.635,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"struct-type-func-overload","title":"Structural Type vs Function Overload","authors":["unional"],"tags":["type-system","structural-type","function-overload"]},"nextItem":{"title":"What is Functional Programming","permalink":"/blog/what-is-fp"}},"content":"Structural type is what I want.\\n\\nFunction overloading is also what I want.\\n\\nCan they co-exist? The answer is no.\\n\\nLet me explain.\\n\\nStructural type avoids a lot of architecture problems existed in nominal type languages.\\n\\nSo to me, when designing a new language or choosing a language to work on,\\nit is *almost* a must (except `rust`, which is too good to pass on).\\n\\nFunction overloading allows the code to be humane,\\nespecially for functional programming.\\n\\nWith function overloading,\\nyou can define the same function with different parameters and different types of parameters with the same name.\\n\\nSo instead of using a different function for each type,\\nyou can call the same function (at least that\'s how it appears at the call site).\\n\\nWhy can\'t they co-exist?\\nLet\'s take a look at an example:\\n\\n```typescript\\ntype A = { a: number }\\ntype B = { b: string }\\n\\nfunction foo(input: A) { /*\u2026snip\u2026*/ }\\n\\nfunction foo(input: B) { /*\u2026snip\u2026*/ }\\n```\\n\\nIf the `input` is `{ a: 1, b: \'b\' }`,\\nthe compiler will not be able to figure out which `foo()` to invoke.\\n\\nNote that when I say function overloading,\\nI mean function with the same name but with different parameters,\\nand each of them have their own implementation.\\n\\ni.e.:\\n\\n```ts\\nfunction foo(input: A) { /*\u2026snip\u2026*/ }\\n\\nfunction foo(input: B) { /*\u2026snip\u2026*/ }\\n```\\n\\nTypeScript\'s function overloading is really signature overloading:\\n\\n```ts\\nfunction foo(input: A): void\\nfunction foo(input: B): void\\nfunction foo(input: A | B) { /*\u2026snip\u2026*/ }\\n```\\n\\nThis difference is important because it allows you to add function overload in different files and modules.\\n\\nWith signature overloading,\\nyou have to know ahead of time all the types you need to support,\\ncreating a top-down dependency same as those in nominal type languages.\\n\\nIn the same fashion, discriminated union has the same problem.\\n\\nIs there a way to solve this?\\n\\nWell, sort of: generics and HKT.\\n\\nBut that\'s a different topic.\\n\\nHappy Coding."},{"id":"what-is-fp","metadata":{"permalink":"/blog/what-is-fp","editUrl":"https://github.com/unional/unional.github.io/edit/main/blog/blog/2021-03-21-what-is-functional-programming.mdx","source":"@site/blog/2021-03-21-what-is-functional-programming.mdx","title":"What is Functional Programming","description":"I have been promoting and migrating from Object-Oriented Programming to Functional Programming for many years, and I loved it.","date":"2021-03-21T00:00:00.000Z","formattedDate":"March 21, 2021","tags":[{"label":"functional programming","permalink":"/blog/tags/functional-programming"},{"label":"just-func","permalink":"/blog/tags/just-func"}],"readingTime":4.14,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"what-is-fp","title":"What is Functional Programming","authors":["unional"],"tags":["functional programming","just-func"]},"prevItem":{"title":"Structural Type vs Function Overload","permalink":"/blog/struct-type-func-overload"}},"content":"I have been promoting and migrating from Object-Oriented Programming to Functional Programming for many years, and I loved it.\\n\\nBut just like everything,\\nthe more you dig into it, the more you realize what you do not know.\\n\\nRecently I have been working on [`just-func`](https://github.com/justland/just-func).\\n\\nI want to design it to be a homoiconic, functional programming language.\\n\\nBut when I put my finger to it,\\nI start wondering what exactly is functional programming.\\n\\nWhen people talk about functional programming,\\nthey often talk about languages such as Lisp, Haskell, F#, Clojure, etc.\\n\\nBut can you do functional programming in other languages?\\n\\nOf course! You can do it in JavaScript/TypeScript,\\nand you can do it in C#, Java, and even C++.\\n\\nThey also talk about pure function, immutability, recursion, monoid, monad, functor, etc.\\n\\nSo do these things define functional programming?\\n\\nIn order to design [`just-func`](https://github.com/justland/just-func) correctly,\\nI send myself on a small research journey.\\n\\n## Functional Programming is a Paradigm\\n\\nFunctional Programming (FP) is a paradigm,\\njust like Object-Oriented Programming (OOP) is a paradigm.\\n\\nWhat is paradigm?\\n\\n> Paradigm is a cognitive framework containing basic assumptions, ways of thinking, and methodology.\\n\\nIn this context, it means that it is a specific approach to programming.\\n\\nFP has its root in lambda calculus, which is a subset of category theory.\\n\\nTherefore, to understand FP, we should first understand category theory.\\n\\nThere is a lot to learn about FP from category theory.\\nBut in this blog, we only need to answer the very first question: what is a category?\\n\\nBartosz Milewski\'s excellent book [Category Theory for Programmers][category-theory-for-programmers] has the perfect description:\\n\\n> A category consists of objects and arrows that go between them.\\n\\nFrom this definition, a category has two things: objects and arrows.\\n\\nWhat is an object? The definition didn\'t specify. It is intentional thou.\\nFor now, let\'s keep it that way.\\n\\nWhat is an arrow? The definition also didn\'t specify.\\nBut it does give a bit more information about it: arrows that go between them.\\n\\nArrow is directional, and \\"go between them\\" means the arrow starts from one object and ends with one object.\\n\\nThe start object and the end object can be the same object, or they can be different.\\n\\nAlso, they are in plural form: objects and arrows.\\nIn mathematics, that means they are a set: a set of objects and a set of arrows.\\n\\nSo putting these back together, the definition becomes:\\n\\n> A category is about *a set of objects `a`* to *a set of objects `b`*,\\n> and *a set of transformations `f`* that transforms `a` to `b`.\\n\\ni.e.: `f(a) \u21fe b`\\n\\nIt is a function!\\n\\nNote that `f`, `a`, and `b` all have their significance.\\n\\nThis means when talking about a specific category,\\nwe need to specify `f`, `a`, and `b`.\\n\\nFrom here, we can derive the two basic *requirements* of FP:\\n\\n1. Since we are talking about mathematics, this function `f(a) \u21fe b` is a formula.\\\\\\n   That means every time you call it with a specific `a\'`, it will always return `b\'`.\\\\\\n   In other words, the function must be pure.\\n2. `a` and `b` are just *set of objects*, this means they can be anything:\\\\\\n   values (such as strings and numbers), set of values (such as arrays, lists, vectors, objects), \\\\\\n   functions (higher-order functions), or set of functions (generics)\\n\\nAny other characteristics of FP are just derivatives of these two requirements.\\nLet list a few here:\\n\\n- Immutable data: this is needed for the function to be pure\\n- First-class function: this preferred (but not required) so that we can use *function* can be value, \\\\\\n  i.e., we can use function as `a` (callback), or `b` (higher-order function).\\n- Closure: this is beneficial (but not required) as it allows functions to capture additional contexts\\n- Declarative programming: this is the result of no needed to mutate data.\\n- Recursion instead of looping: this is the result of not able to mutate data\\n\\nNotice that I italicize *requirements* in \\"We can derive the two basic *requirements* of FP\\",\\nand I also mentioned that first-class function is preferred but not required.\\n\\nIt is because we can always wrap a function in an object and pass it along.\\nIt is very clumsy but is doable.\\nThat is how you write functional code in OOP languages such as Java and C#.\\n\\nTherefore, the ONLY requirement of FP is pure function.\\n\\nThat means you can write functional programming code any programming language.\\n\\nOf course, just that requirement is not that useful.\\nBut it gives you a critical insight:\\n\\n> As long as you can find ways to keep your function pure,\\n> you can get the benefits of functional programming.\\n\\nObviously, there are still a lot more to talk about.\\nI will cover them in the subsequence posts.\\n\\nUntil then, Happy coding!\\n\\n## References\\n\\n- [Clean Coders Humane Code Series](https://cleancoders.com/series/humane-code-real)\\n- [Clean Coders Functional Programming Series](https://cleancoders.com/series/clean-code/functional-programming)\\n- [Category Theory For Programmers][category-theory-for-programmers]\\n- <https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm>\\n- <https://en.wikipedia.org/wiki/Functional_programming>\\n- <https://www.guru99.com/functional-programming-tutorial.html>\\n\\n[category-theory-for-programmers]: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/"}]}')}}]);